- Everything is an object on Windows
	- with a security descriptor
- Object manager is responsible for managing resource object, memory allocations, and lifetimes.
### Object Types
```powershell
Get-NtType #list of supported object types
Get-NtType | Format-List #list of supported object types with property information
```

### Object Manager Namespace (OMNS)
- Built out of directory objects
	- Objects act as if in a filesystem
	- Full paths can be specifies with backslash string (uses book's PowerShell module)
```powershell
ls NtObject:\ | Sort-Object Name
ls NtObject:\Dfs | Select-Object SymbolicLinkTarget #get target of symbolic link target
Get-Item NtObject:\Device\DfsClient | Format-Table 
```
#### Default Object Directories
| Path              | Description                                      |
| ----------------- | ------------------------------------------------ |
| \BaseNamedObjects | Global dir for user objects                      |
| \GLOBAL??         | Global dir for symlinks, includes drive mappings |
| \KnownDlls        | Dir with special known DLL mappings              |
| \ObjectTypes      | Dir with named object types                      |
| \Sessions         | Dir for separate console session                 |
| \Windows          | Dir for objects related to the Window manager    |
| \RPC Control      | Dir for RPC endpoints                            |

- BaseNamedObjects(BNO) allows any user to create named kernel objects
	- sharing of resources between users on the local system
### System Calls
- Allows accessing named objects from user-mode applications
- Usually perform an operation on a specific kernel object type
	- `NtCreateMutant` creates `Mutant` objects.
- Naming is `Zw|Nt` followed by the Operation Verb and then a name relating to the kernel object type
	- `Zw` changes security checking process when invoked by code executed in the kernel
	- `Create`, `Open`, `QueryInformation`, and `SetInformation` are common syscall verbs

#### NtCreateMutant C Prototype
```c
NTSTATUS NtCreateMutant(
HANDLE* FileHandle,
ACCESS_MASK DesiredAccess,
OBJECT_ATTRIBUTES* ObjectAttributes,
BOOLEAN InitialOwner
);
```
- Starts with outbound pointer to a HANDLE
	- Allows access to properties and performing operations
- `DesiredAccess` represents operations the caller wants the ability to perform
- `ObjectAttributes` are the the attributes for the object to open/create
#### OBJECT_ATTRIBUTES Struct
```c
struct OBJECT_ATTRIBUTES {
ULONG Length;
HANDLE RootDirectory;
UNICODE_STRING* ObjectName;
ULONG Attributes;
PVOID SecurityDescriptor;
PVOID SecurityQualityOfService;
}
```
- `RootDirectory` and `ObjectName` are used to look up a resource to access
	- `\BaseNamedObjects\ABC` can be ObjectName = `\BaseNamedObjects\ABC` or RootDirectory = `\BaseNamedObjects` with ObjectName = `ABC`
- `Attributes` is a set of flags to mod the object name lookup or change the handle's properties
##### Attribute Flags Table

| PowerShell Name             | Description                                                                                                              |
| --------------------------- | ------------------------------------------------------------------------------------------------------------------------ |
| Inherit                     | Marks the handle inheritable                                                                                             |
| Permanent                   | Marks the handle as permanent                                                                                            |
| Exclusive                   | Marks the handle as exclusive if creating a new object. Only the same proc can open a handle to the object               |
| CaseInsensitive             | Object name lookup is case insensitive                                                                                   |
| OpenIf                      | Opens a handle to an existing object if available for Create calls                                                       |
| OpenLink                    | pens the object if it's a link to another object or follow the link otherwise. Only used by the config manager<br>       |
| KernelHandle                | Opens handle as a kernel handle when used in kernel mode. Prevents user-mode applications from accessing handle directly |
| ForceAccessCheck            | Forces all access checks are performed when used in kernel mode                                                          |
| IgnoreImpersonatedDeviceMap | Disables the device map when impersonating                                                                               |
| DontReparse                 | Avoids following paths that contain a symlink                                                                            |

### NTSTATUS Codes
- 32-bit code returned by all syscalls
![[NT status code structure.png]]

#### Severity Bits

| Severity name                 | Value |
| ----------------------------- | ----- |
| STATUS_SEVERITY_SUCCESS       | 0     |
| STATUS_SEVERITY_INFORMATIONAL | 1     |
| STATUS_SEVERITY_WARNING       | 2     |
| STATUS_SEVERITY_ERROR         | 3     |
- If the status code is treated as a signed 32-bit int then errors will return a negative value (31st bit will be 1)
#### Customer Code (CC)
- `0` for Microsoft defined status codes and `1` for third parties
#### Reserved (R)
- Must be set to `0`
#### Facilities
- 12 bits to indicate component/subsystem associated with the status code. 
	- Microsoft has around 50
	- Third parities to should make custom facilities

| Facility Name     | Value | Description                                        |
| ----------------- | ----- | -------------------------------------------------- |
| FACILITY_DEFAULT  | 0     | The default used for common status codes           |
| FACILITY_DEBUGGER | 1     | Used for codes associated with the debugger        |
| FACILITY_NTWIN32  | 7     | Used for codes that originated from the Win32 APIs |

#### status code
- 16 bit number that is set by the implementer
	- unique per facility
- `Get-NtStatus` with no params will list out known status codes
```powershell
Get-NtStatus

Get-NtStatus 0xC0000034 | Format-List
```

### Object Handles
- User-mode applications must use handles returned by syscalls to access objects
- Every running process has a handle table
1. The handle's numeric identifier
2. The granted access to handle (i.e. rw)
3. The pointer to the object struct in kernel memory
- Syscall implementation looks up the kernel object pointer from the handle table using an api for a kernel to use a handle
	- ObReferenceObjectByHandle
	- This avoids exposing the kernel object
![[Handle Table Lookup.png]]

1. Pass handle value to syscall
2. Syscall calls a kernel API to convert handle to a kernel pointer via referencing handle's numeric value in the handle table
3. Conversion API checks access permission and object type
	- `STATUS_ACCESS_DENIED` or `STATUS_OBJECT_TYPE_MISMATCH` otherwise
### Access Masks
